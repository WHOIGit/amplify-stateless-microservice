"""Utilities for generating Apache reverse-proxy configs for Amplify services."""

import argparse
from dataclasses import dataclass
from pathlib import Path
from textwrap import dedent

DEFAULT_TEMPLATE = """\
# Generated by amplify-microservice for service: {service_name}
{virtual_host_open}
{server_name_line}
{ssl_block}
{proxy_preserve_host}
{forward_headers}

{proxy_pass_line}
{proxy_pass_reverse_line}

{error_log_line}
{access_log_line}
{virtual_host_close}
"""


@dataclass
class ApacheConfigParams:
    service_name: str
    public_host: str
    backend_url: str
    backend_path: str
    route_path: str
    error_log: str
    access_log: str
    use_https: bool
    include_virtualhost: bool
    ssl_certificate_file: str | None = None
    ssl_certificate_key_file: str | None = None

    @property
    def forwarded_proto(self) -> str:
        return "https" if self.use_https else "http"

    @property
    def forwarded_port(self) -> str:
        return "443" if self.use_https else "80"

    @property
    def virtual_host_open(self) -> str:
        if not self.include_virtualhost:
            return "# VirtualHost handled by parent configuration"
        port = "443" if self.use_https else "80"
        return f"<VirtualHost *:{port}>"

    @property
    def virtual_host_close(self) -> str:
        return "</VirtualHost>" if self.include_virtualhost else "# End fragment"

    @property
    def server_name_line(self) -> str:
        return f"ServerName {self.public_host}" if self.include_virtualhost else f"# ServerName {self.public_host}"

    @property
    def ssl_block(self) -> str:
        if not self.include_virtualhost:
            return "# SSL handled by parent configuration"
        if not self.use_https:
            return "# Proxying over HTTP"
        cert = self.ssl_certificate_file or "/etc/ssl/certs/example.crt"
        key = self.ssl_certificate_key_file or "/etc/ssl/private/example.key"
        return dedent(
            f"""\
            SSLEngine on
            SSLCertificateFile {cert}
            SSLCertificateKeyFile {key}"""
        ).strip()

    @property
    def proxy_preserve_host(self) -> str:
        return "ProxyPreserveHost On"

    @property
    def forward_headers(self) -> str:
        return (
            f"RequestHeader set X-Forwarded-Proto \"{self.forwarded_proto}\"\n"
            f"RequestHeader set X-Forwarded-Port \"{self.forwarded_port}\""
        )

    @property
    def indent(self) -> str:
        return "    " if self.include_virtualhost else ""

def sanitize_path(value: str) -> str:
    value = value.strip()
    if not value:
        return "/"
    if not value.startswith("/"):
        value = "/" + value
    if not value.endswith("/"):
        value += "/"
    return value


def normalize_backend(backend: str) -> tuple[str, str]:
    backend = backend.rstrip("/")
    for scheme in ("http://", "https://"):
        if backend.startswith(scheme):
            parts = backend[len(scheme) :].split("/", 1)
            host = parts[0]
            remainder = "/" + parts[1] if len(parts) == 2 else ""
            return f"{scheme}{host}", remainder or "/"
    raise ValueError(f"Backend must include scheme (http:// or https://), got: {backend}")


def generate_apache_vhost_config(params: ApacheConfigParams, template: str = DEFAULT_TEMPLATE) -> str:
    def _indent_block(text: str) -> str:
        if not text:
            return ""
        indent = params.indent
        if not indent:
            return text
        return "\n".join(f"{indent}{line}" if line else "" for line in text.splitlines())

    proxy_pass = (
        f"ProxyPass        {params.route_path} {params.backend_url}{params.backend_path} "
        "retry=1 acquire=3000 timeout=600 keepalive=On"
    )
    proxy_pass_reverse = (
        f"ProxyPassReverse {params.route_path} {params.backend_url}{params.backend_path}"
    )
    error_log_line = f"ErrorLog  {params.error_log}"
    access_log_line = f"CustomLog {params.access_log} combined"

    rendered = template.format(
        service_name=params.service_name,
        public_host=params.public_host,
        backend_url=params.backend_url,
        backend_path=params.backend_path,
        route_path=params.route_path,
        error_log=params.error_log,
        access_log=params.access_log,
        forwarded_proto=params.forwarded_proto,
        forwarded_port=params.forwarded_port,
        virtual_host_open=params.virtual_host_open,
        virtual_host_close=params.virtual_host_close,
        server_name_line=_indent_block(params.server_name_line),
        ssl_block=_indent_block(params.ssl_block),
        proxy_preserve_host=_indent_block(params.proxy_preserve_host),
        forward_headers=_indent_block(params.forward_headers),
        proxy_pass_line=_indent_block(proxy_pass),
        proxy_pass_reverse_line=_indent_block(proxy_pass_reverse),
        error_log_line=_indent_block(error_log_line),
        access_log_line=_indent_block(access_log_line),
    )
    return "\n".join(line.rstrip() for line in rendered.splitlines())


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate an Apache reverse-proxy config for an Amplify microservice.",
    )
    parser.add_argument("--service", required=True, help="Service short name (used in comment/log names).")
    parser.add_argument("--hostname", required=True, help="Public hostname (ServerName).")
    parser.add_argument("--backend", required=True, help="Backend URL with scheme and port, e.g. http://127.0.0.1:8010")
    parser.add_argument("--path", default="/", help="Public route path prefix (default: /).")
    parser.add_argument(
        "--https",
        action="store_true",
        help="Generate an HTTPS vhost block (includes placeholder cert paths).",
    )
    parser.add_argument(
        "--no-virtualhost",
        action="store_true",
        help="Emit only proxy directives without wrapping <VirtualHost>.",
    )
    parser.add_argument("--ssl-cert", help="Path to SSLCertificateFile when using --https.")
    parser.add_argument("--ssl-key", help="Path to SSLCertificateKeyFile when using --https.")
    parser.add_argument("--error-log", help="Apache error log path.", default="/var/log/apache2/{service}-error.log")
    parser.add_argument("--access-log", help="Apache access log path.", default="/var/log/apache2/{service}-access.log")
    parser.add_argument("--output", help="Write config to this path. Use '-' for stdout.", default="-")
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> int:
    args = parse_args(argv)

    backend_url, backend_path = normalize_backend(args.backend)
    route_path = sanitize_path(args.path)

    error_log = args.error_log.format(service=args.service)
    access_log = args.access_log.format(service=args.service)

    params = ApacheConfigParams(
        service_name=args.service,
        public_host=args.hostname,
        backend_url=backend_url,
        backend_path=backend_path,
        route_path=route_path,
        error_log=error_log,
        access_log=access_log,
        use_https=args.https,
        include_virtualhost=not args.no_virtualhost,
        ssl_certificate_file=args.ssl_cert,
        ssl_certificate_key_file=args.ssl_key,
    )

    config_text = generate_apache_vhost_config(params)

    if args.output == "-":
        print(config_text)
    else:
        output_path = Path(args.output)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(config_text + "\n")
        print(f"Wrote Apache config to {output_path}")

    return 0


if __name__ == "__main__":  # pragma: no cover - manual invocation
    raise SystemExit(main())
